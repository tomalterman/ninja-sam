<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Ninja Sam - Robot Runner</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #1a1a2e;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            min-height: 100vh;
            padding: 10px;
            font-family: 'Courier New', monospace;
            overflow-x: hidden;
            overflow-y: auto;
        }

        #gameContainer {
            position: relative;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        #gameCanvas {
            display: block;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            border: 4px solid #4a4a6a;
            border-radius: 4px;
        }

        #touchControls {
            position: absolute;
            bottom: 20px;
            left: 0;
            right: 0;
            display: none;
            justify-content: space-between;
            padding: 0 20px;
            pointer-events: none;
        }

        .touchBtn {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            border: 3px solid rgba(255, 255, 255, 0.4);
            color: white;
            font-size: 14px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            user-select: none;
            -webkit-user-select: none;
        }

        .touchBtn:active {
            background: rgba(255, 255, 255, 0.4);
        }

        @media (pointer: coarse) {
            #touchControls {
                display: flex;
            }
            #instructions {
                display: none;
            }
        }

        @media (max-height: 700px) {
            #highScores h2 {
                font-size: 14px;
                margin-bottom: 5px;
            }
            .scoreEntry {
                font-size: 12px;
                margin: 2px 0;
            }
        }

        #instructions {
            color: #aaa;
            text-align: center;
            margin-top: 15px;
            font-size: 14px;
        }

        #instructions p {
            margin: 5px 0;
        }

        #instructions strong {
            color: #ffd700;
        }

        #highScores {
            color: #fff;
            text-align: center;
            margin-top: 15px;
            font-family: 'Courier New', monospace;
        }

        #highScores h2 {
            color: #ffd700;
            font-size: 18px;
            margin-bottom: 10px;
            letter-spacing: 2px;
        }

        .scoreEntry {
            font-size: 14px;
            margin: 4px 0;
            transition: all 0.3s;
        }

        .scoreEntry.new {
            animation: newScore 0.5s ease-out;
            color: #ffd700;
        }

        .scoreEntry .rank {
            color: #ff4757;
        }

        .scoreEntry .name {
            color: #5c6bc0;
            margin: 0 10px;
        }

        .scoreEntry .score {
            color: #fff;
        }

        @keyframes newScore {
            0% { transform: scale(2); opacity: 0; }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); opacity: 1; }
        }

        @keyframes pixelate {
            0% { filter: blur(4px); transform: scale(1.5); opacity: 0; }
            30% { filter: blur(2px); }
            100% { filter: blur(0); transform: scale(1); opacity: 1; }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="touchControls">
            <div class="touchBtn" id="jumpBtn">JUMP</div>
            <div class="touchBtn" id="slashBtn">SLASH</div>
        </div>
    </div>
    <div id="instructions">
        <p><strong>JUMP:</strong> Space, W, or Arrow Up</p>
        <p><strong>SLASH:</strong> S, D, or Shift</p>
    </div>
    <div id="highScores">
        <h2>HIGH SCORES</h2>
        <div id="scoreList">
            <div class="scoreEntry"><span class="rank">1.</span> <span class="name">---</span> <span class="score">000000</span></div>
            <div class="scoreEntry"><span class="rank">2.</span> <span class="name">---</span> <span class="score">000000</span></div>
            <div class="scoreEntry"><span class="rank">3.</span> <span class="name">---</span> <span class="score">000000</span></div>
        </div>
    </div>

    <script>
        // ==================== GAME CONFIGURATION ====================
        const CONFIG = {
            // Base resolution (SNES-style)
            BASE_WIDTH: 384,
            BASE_HEIGHT: 216,
            SCALE: 3,

            // Physics
            GRAVITY: 0.5,
            JUMP_FORCE: -10,
            FLOAT_GRAVITY: 0.15,  // Reduced gravity at peak for hang time
            GROUND_Y: 170,

            // Game speed
            SCROLL_SPEED: 2,
            ROBOT_SPEED: 1.6,

            // Timing (in frames at 60fps)
            JUMP_DURATION: 36,      // ~0.6 seconds
            SLASH_DURATION: 18,     // ~0.3 seconds
            SLASH_COOLDOWN: 36,     // ~0.6 seconds
            INVINCIBILITY: 90,      // ~1.5 seconds

            // Spawning
            MIN_SPAWN_INTERVAL: 60,
            MAX_SPAWN_INTERVAL: 150,

            // Colors (SNES palette style)
            COLORS: {
                SKY: '#1a1a2e',
                MOUNTAINS: '#16213e',
                BUILDINGS: '#0f3460',
                GROUND: '#533483',
                GROUND_TOP: '#7952a3',
                NINJA: '#1a1a1a',
                NINJA_ACCENT: '#333333',
                NINJA_SKIN: '#ffccaa',
                NINJA_HAIR: '#f4d03f',
                NINJA_HAIR_DARK: '#c9a227',
                FLAME_INNER: '#ffffff',
                FLAME_MID: '#ffff00',
                FLAME_OUTER: '#ff6600',
                FLAME_TIP: '#ff0000',
                ROBOT_BODY: '#ff4444',
                ROBOT_ACCENT: '#ffff00',
                ROBOT_EYES: '#ffffff',
                SLASH: '#ffd700',
                UI_TEXT: '#ffffff',
                HEALTH: '#ff4757'
            }
        };

        // ==================== DEBUG CONFIG ====================
        const DEBUG = {
            showFps: new URLSearchParams(window.location.search).get('debug')?.includes('fps') || false,
            frameTime: 0,
            slowFrameCount: 0,
            totalFrames: 0,
            fps: 0,
            fpsFrames: 0,
            fpsLastTime: 0
        };

        // ==================== GAME STATE ====================
        const game = {
            canvas: null,
            ctx: null,
            running: false,
            gameOver: false,
            score: 0,
            combo: 1,
            health: 3,
            survivalTime: 0,
            spawnTimer: 0,
            nextSpawnTime: 100,
            difficulty: 1,

            // High score entry
            enteringName: false,
            playerName: '',
            newHighScoreRank: -1,

            // Input state
            keys: {
                jump: false,
                slash: false,
                slashUsed: false  // Prevents holding key to spam
            }
        };

        // ==================== HIGH SCORES ====================
        let highScores = [
            { name: '---', score: 0 },
            { name: '---', score: 0 },
            { name: '---', score: 0 }
        ];

        // Remember last player name for the session
        let lastPlayerName = sessionStorage.getItem('ninjaSamLastName') || '';

        // Touch keyboard state
        const touchKeyboard = {
            letters: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split(''),
            backspace: 'â†',
            enter: 'OK',
            buttonSize: 28,
            startY: 0  // Will be calculated based on canvas
        };

        function loadHighScores() {
            const saved = localStorage.getItem('ninjaSamHighScores');
            if (saved) {
                highScores = JSON.parse(saved);
            }
            updateHighScoreDisplay();
        }

        function saveHighScores() {
            localStorage.setItem('ninjaSamHighScores', JSON.stringify(highScores));
        }

        function updateHighScoreDisplay() {
            const entries = document.querySelectorAll('.scoreEntry');
            entries.forEach((entry, i) => {
                entry.querySelector('.name').textContent = highScores[i].name;
                entry.querySelector('.score').textContent = String(highScores[i].score).padStart(6, '0');
            });
        }

        function checkHighScore(score) {
            for (let i = 0; i < 3; i++) {
                if (score > highScores[i].score) {
                    return i;
                }
            }
            return -1;
        }

        function addHighScore(name, score, rank) {
            // Save name for future sessions
            lastPlayerName = name.toUpperCase();
            sessionStorage.setItem('ninjaSamLastName', lastPlayerName);

            // Insert new score at rank
            highScores.splice(rank, 0, { name: name.toUpperCase(), score: score });
            // Keep only top 3
            highScores = highScores.slice(0, 3);
            saveHighScores();

            // Animate the new entry
            updateHighScoreDisplay();
            const entries = document.querySelectorAll('.scoreEntry');
            entries[rank].classList.add('new');
            setTimeout(() => entries[rank].classList.remove('new'), 1000);
        }

        // ==================== NINJA PLAYER ====================
        const ninja = {
            x: 80,
            y: CONFIG.GROUND_Y,
            width: 24,
            height: 32,
            velocityY: 0,
            isJumping: false,
            isSlashing: false,
            slashTimer: 0,
            slashCooldown: 0,
            invincible: 0,
            animFrame: 0,
            animTimer: 0,
            hitReaction: 0,      // Timer for hit stagger animation
            deathAnim: 0,        // Timer for death animation
            isDead: false
        };

        // ==================== ENTITIES ====================
        let robots = [];
        let fruits = [];
        let particles = [];
        let scorePopups = [];

        // Fruit types with colors
        const FRUIT_TYPES = [
            { name: 'pineapple', bodyColor: '#f4d03f', topColor: '#27ae60' },
            { name: 'banana', bodyColor: '#f1c40f', topColor: '#f39c12' },
            { name: 'cherry', bodyColor: '#e74c3c', topColor: '#27ae60' },
            { name: 'apple', bodyColor: '#e74c3c', topColor: '#27ae60' },
            { name: 'strawberry', bodyColor: '#ff6b6b', topColor: '#27ae60' }
        ];

        // ==================== PARALLAX BACKGROUND ====================
        const background = {
            stars: Array.from({length: 20}, () => ({
                x: Math.random() * CONFIG.BASE_WIDTH,
                y: Math.random() * 80,
                size: Math.random() < 0.3 ? 2 : 1
            })),
            clouds: [
                { x: 50, y: 30, width: 60 },
                { x: 200, y: 45, width: 45 },
                { x: 350, y: 25, width: 55 },
                { x: 500, y: 40, width: 50 }
            ],
            mountains: [
                { x: 0, width: 200, height: 60 },
                { x: 180, width: 150, height: 45 },
                { x: 320, width: 180, height: 55 },
                { x: 500, width: 160, height: 50 }
            ],
            buildings: [
                { x: 0, width: 60, height: 80, color: '#1a237e', hasSign: true },
                { x: 70, width: 45, height: 60, color: '#0d47a1', hasSign: false },
                { x: 130, width: 70, height: 90, color: '#1565c0', hasSign: true },
                { x: 210, width: 50, height: 70, color: '#0d47a1', hasSign: false },
                { x: 280, width: 65, height: 85, color: '#1a237e', hasSign: true },
                { x: 360, width: 55, height: 65, color: '#1565c0', hasSign: false },
                { x: 430, width: 75, height: 95, color: '#0d47a1', hasSign: true }
            ],
            groundOffset: 0
        };

        // ==================== INITIALIZATION ====================
        function init() {
            game.canvas = document.getElementById('gameCanvas');
            game.ctx = game.canvas.getContext('2d');

            // Set canvas size
            game.canvas.width = CONFIG.BASE_WIDTH;
            game.canvas.height = CONFIG.BASE_HEIGHT;

            // Scale canvas display
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            // Setup input
            setupInput();

            // Load high scores
            loadHighScores();

            // Start game
            resetGame();
            game.running = true;
            requestAnimationFrame(gameLoop);
        }

        function resizeCanvas() {
            const container = document.getElementById('gameContainer');
            const maxWidth = window.innerWidth - 20;
            // Reserve space for instructions and high scores
            const isTouchDevice = window.matchMedia('(pointer: coarse)').matches;
            const reservedHeight = isTouchDevice ? 120 : 180;
            const maxHeight = window.innerHeight - reservedHeight;

            let scale = Math.min(
                maxWidth / CONFIG.BASE_WIDTH,
                maxHeight / CONFIG.BASE_HEIGHT
            );

            // Round down to nearest integer for crisp pixels (min 1)
            scale = Math.max(1, Math.floor(scale));

            game.canvas.style.width = (CONFIG.BASE_WIDTH * scale) + 'px';
            game.canvas.style.height = (CONFIG.BASE_HEIGHT * scale) + 'px';
        }

        function resetGame() {
            game.score = 0;
            game.combo = 1;
            game.health = 3;
            game.survivalTime = 0;
            game.spawnTimer = 0;
            game.nextSpawnTime = 300; // 5 seconds before first robot
            game.difficulty = 1;
            game.gameOver = false;
            game.enteringName = false;
            game.playerName = '';
            game.newHighScoreRank = -1;

            ninja.y = CONFIG.GROUND_Y;
            ninja.velocityY = 0;
            ninja.isJumping = false;
            ninja.isSlashing = false;
            ninja.slashTimer = 0;
            ninja.slashCooldown = 0;
            ninja.invincible = 60; // Brief invincibility at start
            ninja.hitReaction = 0;
            ninja.deathAnim = 0;
            ninja.isDead = false;

            robots = [];
            fruits = [];
            particles = [];
            scorePopups = [];
            fruitSpawnTimer = 0;
            nextFruitSpawnTime = 200;
        }

        // ==================== INPUT HANDLING ====================
        function setupInput() {
            // Keyboard
            document.addEventListener('keydown', (e) => {
                // Handle high score name entry
                if (game.gameOver && game.enteringName) {
                    e.preventDefault();
                    if (e.code === 'Enter' && game.playerName.length === 3) {
                        // Submit name
                        addHighScore(game.playerName, game.score, game.newHighScoreRank);
                        game.enteringName = false;
                    } else if (e.code === 'Backspace' && game.playerName.length > 0) {
                        game.playerName = game.playerName.slice(0, -1);
                    } else if (e.key.length === 1 && e.key.match(/[a-zA-Z]/) && game.playerName.length < 3) {
                        game.playerName += e.key.toUpperCase();
                    }
                    return;
                }

                // Handle restart
                if (game.gameOver) {
                    if (e.code === 'Space' || e.code === 'Enter') {
                        e.preventDefault();
                        resetGame();
                    }
                    return; // Don't process other inputs when game over
                }

                if (e.code === 'Space' || e.code === 'KeyW' || e.code === 'ArrowUp') {
                    e.preventDefault();
                    game.keys.jump = true;
                }
                if (e.code === 'KeyS' || e.code === 'KeyD' || e.code === 'ShiftLeft' || e.code === 'ShiftRight') {
                    e.preventDefault();
                    game.keys.slash = true;
                }
            });

            document.addEventListener('keyup', (e) => {
                if (e.code === 'Space' || e.code === 'KeyW' || e.code === 'ArrowUp') {
                    game.keys.jump = false;
                }
                if (e.code === 'KeyS' || e.code === 'KeyD' || e.code === 'ShiftLeft' || e.code === 'ShiftRight') {
                    game.keys.slash = false;
                    game.keys.slashUsed = false;  // Allow slashing again after key release
                }
            });

            // Touch controls
            const jumpBtn = document.getElementById('jumpBtn');
            const slashBtn = document.getElementById('slashBtn');

            jumpBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (game.gameOver && !game.enteringName) {
                    resetGame();
                    return;
                }
                game.keys.jump = true;
            });
            jumpBtn.addEventListener('touchend', () => game.keys.jump = false);

            slashBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (game.gameOver && !game.enteringName) {
                    resetGame();
                    return;
                }
                game.keys.slash = true;
            });
            slashBtn.addEventListener('touchend', () => { game.keys.slash = false; game.keys.slashUsed = false; });

            // Click/touch handler for game over screen and keyboard
            function handleCanvasInteraction(e) {
                e.preventDefault();

                // Get canvas coordinates
                const rect = game.canvas.getBoundingClientRect();
                const scaleX = CONFIG.BASE_WIDTH / rect.width;
                const scaleY = CONFIG.BASE_HEIGHT / rect.height;

                let clientX, clientY;
                if (e.touches && e.touches.length > 0) {
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                } else {
                    clientX = e.clientX;
                    clientY = e.clientY;
                }

                const canvasX = (clientX - rect.left) * scaleX;
                const canvasY = (clientY - rect.top) * scaleY;

                if (game.gameOver) {
                    if (game.enteringName) {
                        // Handle keyboard touch
                        handleKeyboardTouch(canvasX, canvasY);
                    } else {
                        // Restart game
                        resetGame();
                    }
                }
            }

            game.canvas.addEventListener('click', handleCanvasInteraction);
            game.canvas.addEventListener('touchstart', handleCanvasInteraction);
        }

        // ==================== GAME LOOP ====================
        let lastTime = 0;
        const TARGET_FPS = 60;
        const FRAME_TIME = 1000 / TARGET_FPS;

        function gameLoop(currentTime) {
            const frameStart = performance.now();

            requestAnimationFrame(gameLoop);

            if (!game.running) return;

            // Calculate delta time (1.0 = one 60fps frame, 0.5 = one 120fps frame)
            const deltaTime = lastTime ? Math.min((currentTime - lastTime) / FRAME_TIME, 3) : 1;
            lastTime = currentTime;

            // Update
            if (!game.gameOver) {
                update(deltaTime);
            }

            // Render
            render();

            // Track frame timing for debug
            if (DEBUG.showFps) {
                DEBUG.frameTime = performance.now() - frameStart;
                DEBUG.totalFrames++;
                DEBUG.fpsFrames++;
                if (DEBUG.frameTime > 16.67) {
                    DEBUG.slowFrameCount++;
                }
                // Calculate FPS every second
                if (currentTime - DEBUG.fpsLastTime >= 1000) {
                    DEBUG.fps = DEBUG.fpsFrames;
                    DEBUG.fpsFrames = 0;
                    DEBUG.fpsLastTime = currentTime;
                }
            }
        }

        function update(dt) {
            // Survival time score
            game.survivalTime += dt;
            if (Math.floor(game.survivalTime / 60) > Math.floor((game.survivalTime - dt) / 60)) {
                game.score += 1;
            }

            // Increase difficulty over time
            game.difficulty = 1 + Math.floor(game.survivalTime / 600) * 0.2;

            // Update ninja
            updateNinja(dt);

            // Update robots
            updateRobots(dt);

            // Update particles
            updateParticles(dt);

            // Update score popups
            updateScorePopups(dt);

            // Spawn robots and fruit
            spawnRobots(dt);
            spawnFruit(dt);

            // Update fruit
            updateFruit(dt);

            // Check collisions (not during death animation)
            if (!ninja.isDead) {
                checkCollisions();
            }

            // Update background
            updateBackground(dt);
        }

        // ==================== NINJA UPDATE ====================
        function updateNinja(dt) {
            // Death animation - only update death timer
            if (ninja.isDead) {
                ninja.deathAnim -= dt;
                if (ninja.deathAnim <= 0) {
                    game.gameOver = true;
                    game.newHighScoreRank = checkHighScore(game.score);
                    if (game.newHighScoreRank >= 0) {
                        game.enteringName = true;
                        game.playerName = lastPlayerName; // Prefill with last used name
                    }
                }
                return; // Skip all other ninja updates during death
            }

            // Animation
            ninja.animTimer += dt;
            if (ninja.animTimer >= 6) {
                ninja.animTimer = 0;
                ninja.animFrame = (ninja.animFrame + 1) % 4;
            }

            // Jump
            if (game.keys.jump && !ninja.isJumping) {
                ninja.isJumping = true;
                ninja.velocityY = CONFIG.JUMP_FORCE;
            }

            // Apply gravity
            if (ninja.isJumping) {
                // Use reduced gravity near the peak for hang time
                const isNearPeak = Math.abs(ninja.velocityY) < 3;
                const gravity = isNearPeak ? CONFIG.FLOAT_GRAVITY : CONFIG.GRAVITY;

                ninja.velocityY += gravity * dt;
                ninja.y += ninja.velocityY * dt;

                // Land
                if (ninja.y >= CONFIG.GROUND_Y) {
                    ninja.y = CONFIG.GROUND_Y;
                    ninja.isJumping = false;
                    ninja.velocityY = 0;
                }
            }

            // Slash
            if (ninja.slashCooldown > 0) {
                ninja.slashCooldown -= dt;
            }

            if (game.keys.slash && !game.keys.slashUsed && !ninja.isSlashing && ninja.slashCooldown <= 0) {
                ninja.isSlashing = true;
                ninja.slashTimer = CONFIG.SLASH_DURATION;
                game.keys.slashUsed = true;  // Must release key before slashing again
            }

            if (ninja.isSlashing) {
                ninja.slashTimer -= dt;
                if (ninja.slashTimer <= 0) {
                    ninja.isSlashing = false;
                    ninja.slashCooldown = CONFIG.SLASH_COOLDOWN;
                }
            }

            // Invincibility
            if (ninja.invincible > 0) {
                ninja.invincible -= dt;
            }

            // Hit reaction timer
            if (ninja.hitReaction > 0) {
                ninja.hitReaction -= dt;
            }
        }

        // ==================== ROBOT SPAWNING & UPDATE ====================
        function spawnRobots(dt) {
            game.spawnTimer += dt;

            if (game.spawnTimer >= game.nextSpawnTime) {
                game.spawnTimer = 0;

                // Decrease spawn interval as difficulty increases
                const minInterval = Math.max(30, CONFIG.MIN_SPAWN_INTERVAL - game.difficulty * 10);
                const maxInterval = Math.max(60, CONFIG.MAX_SPAWN_INTERVAL - game.difficulty * 20);
                game.nextSpawnTime = minInterval + Math.random() * (maxInterval - minInterval);

                // Spawn robot
                const isTall = Math.random() < 0.3 + game.difficulty * 0.1;
                robots.push({
                    x: CONFIG.BASE_WIDTH + 20,
                    y: CONFIG.GROUND_Y,
                    width: isTall ? 28 : 24,
                    height: isTall ? 40 : 28,
                    isTall: isTall,
                    animFrame: 0,
                    animTimer: 0,
                    jumped: false  // Track if player jumped over this robot
                });
            }
        }

        function updateRobots(dt) {
            for (let i = robots.length - 1; i >= 0; i--) {
                const robot = robots[i];

                // Move
                robot.x -= (CONFIG.ROBOT_SPEED + CONFIG.SCROLL_SPEED * 0.5) * dt;

                // Animate
                robot.animTimer += dt;
                if (robot.animTimer >= 8) {
                    robot.animTimer = 0;
                    robot.animFrame = (robot.animFrame + 1) % 4;
                }

                // Remove if off screen
                if (robot.x < -robot.width) {
                    robots.splice(i, 1);
                }
            }
        }

        // ==================== FRUIT SPAWNING & UPDATE ====================
        let fruitSpawnTimer = 0;
        let nextFruitSpawnTime = 200;

        function spawnFruit(dt) {
            fruitSpawnTimer += dt;

            if (fruitSpawnTimer >= nextFruitSpawnTime) {
                fruitSpawnTimer = 0;
                nextFruitSpawnTime = 180 + Math.random() * 120;

                const fruitType = FRUIT_TYPES[Math.floor(Math.random() * FRUIT_TYPES.length)];
                const flyHeight = 90 + Math.random() * 20; // Height in the air (matches jump peak)

                fruits.push({
                    x: CONFIG.BASE_WIDTH + 20,
                    y: CONFIG.GROUND_Y - flyHeight,
                    width: 20,
                    height: 20,
                    type: fruitType,
                    bobOffset: Math.random() * Math.PI * 2,
                    bobTimer: 0
                });
            }
        }

        function updateFruit(dt) {
            for (let i = fruits.length - 1; i >= 0; i--) {
                const fruit = fruits[i];

                // Move
                fruit.x -= (CONFIG.SCROLL_SPEED + 1) * dt;

                // Bob up and down
                fruit.bobTimer += 0.1 * dt;
                fruit.baseY = fruit.y;

                // Remove if off screen
                if (fruit.x < -fruit.width) {
                    fruits.splice(i, 1);
                }
            }
        }

        // ==================== COLLISION DETECTION ====================
        function checkCollisions() {
            const ninjaBox = {
                x: ninja.x - ninja.width / 2,
                y: ninja.y - ninja.height,
                width: ninja.width,
                height: ninja.height
            };

            // Ninja feet hitbox (for stomping)
            const feetBox = {
                x: ninja.x - 8,
                y: ninja.y - 6,
                width: 16,
                height: 6
            };

            // Slash hitbox (follows sword swing arc)
            let slashBox = null;
            if (ninja.isSlashing) {
                const slashProgress = 1 - ninja.slashTimer / CONFIG.SLASH_DURATION;
                const eased = 1 - (1 - slashProgress) * (1 - slashProgress);
                const swordAngle = -2.2 + eased * 2.6;
                const swordLength = 32;
                const pivotX = ninja.x + 12;
                const pivotY = ninja.y - 10;

                // Hitbox at sword tip area
                const tipX = pivotX + Math.cos(swordAngle) * swordLength;
                const tipY = pivotY + Math.sin(swordAngle) * swordLength;

                slashBox = {
                    x: tipX - 15,
                    y: tipY - 15,
                    width: 30,
                    height: 30
                };
            }

            for (let i = robots.length - 1; i >= 0; i--) {
                const robot = robots[i];
                const robotBox = {
                    x: robot.x - robot.width / 2,
                    y: robot.y - robot.height,
                    width: robot.width,
                    height: robot.height
                };

                // Robot head hitbox (for stomping)
                const robotHeadBox = {
                    x: robot.x - robot.width / 2,
                    y: robot.y - robot.height,
                    width: robot.width,
                    height: 10
                };

                // Check stomp collision (ninja falling and feet hit robot head)
                if (ninja.isJumping && ninja.velocityY > 0 && boxCollision(feetBox, robotHeadBox)) {
                    // Squash the robot!
                    destroyRobot(robot, i, true);
                    addScore(25, robot.x, robot.y - robot.height);
                    // Bounce up
                    ninja.velocityY = CONFIG.JUMP_FORCE * 0.6;
                    continue;
                }

                // Check if ninja jumped over robot
                if (!robot.jumped && ninja.isJumping &&
                    ninja.x > robot.x - 10 && ninja.x < robot.x + 10 &&
                    ninja.y - ninja.height < robot.y - robot.height) {
                    robot.jumped = true;
                    addScore(10, robot.x, robot.y - robot.height);
                }

                // Check slash collision
                if (slashBox && boxCollision(slashBox, robotBox)) {
                    // Destroy robot
                    destroyRobot(robot, i);
                    addScore(25, robot.x, robot.y - robot.height);
                    continue;
                }

                // Check body collision
                if (ninja.invincible === 0 && boxCollision(ninjaBox, robotBox)) {
                    takeDamage();
                }
            }

            // Check fruit collisions (slash only)
            for (let i = fruits.length - 1; i >= 0; i--) {
                const fruit = fruits[i];
                const bobY = Math.sin(fruit.bobTimer + fruit.bobOffset) * 5;
                const fruitBox = {
                    x: fruit.x - fruit.width / 2,
                    y: fruit.y + bobY - fruit.height / 2,
                    width: fruit.width,
                    height: fruit.height
                };

                // Only slashing can hit fruit
                if (slashBox && boxCollision(slashBox, fruitBox)) {
                    destroyFruit(fruit, i);
                    addScore(75, fruit.x, fruit.y + bobY); // 3x points!
                }
            }
        }

        function boxCollision(a, b) {
            return a.x < b.x + b.width &&
                   a.x + a.width > b.x &&
                   a.y < b.y + b.height &&
                   a.y + a.height > b.y;
        }

        function destroyRobot(robot, index, squashed = false) {
            // Create explosion particles
            const particleCount = squashed ? 5 : 8;
            for (let i = 0; i < particleCount; i++) {
                particles.push({
                    x: robot.x,
                    y: squashed ? robot.y - 5 : robot.y - robot.height / 2,
                    vx: (Math.random() - 0.5) * (squashed ? 12 : 8),
                    vy: squashed ? (Math.random() - 0.8) * 4 : (Math.random() - 0.5) * 8 - 2,
                    size: 3 + Math.random() * 4,
                    color: Math.random() < 0.5 ? CONFIG.COLORS.ROBOT_ACCENT : CONFIG.COLORS.ROBOT_BODY,
                    life: 30
                });
            }

            robots.splice(index, 1);
        }

        function destroyFruit(fruit, index) {
            // Create colorful fruit explosion particles
            for (let i = 0; i < 6; i++) {
                const bobY = Math.sin(fruit.bobTimer + fruit.bobOffset) * 5;
                particles.push({
                    x: fruit.x,
                    y: fruit.y + bobY,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10 - 2,
                    size: 3 + Math.random() * 5,
                    color: Math.random() < 0.7 ? fruit.type.bodyColor : fruit.type.topColor,
                    life: 35
                });
            }

            fruits.splice(index, 1);
        }

        function takeDamage() {
            game.health--;
            ninja.invincible = CONFIG.INVINCIBILITY;
            ninja.hitReaction = 30; // 0.5 second hit stagger
            game.combo = 1;

            // Screen shake effect (simple version - just particles)
            for (let i = 0; i < 5; i++) {
                particles.push({
                    x: ninja.x,
                    y: ninja.y - ninja.height / 2,
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8,
                    size: 4 + Math.random() * 3,
                    color: CONFIG.COLORS.HEALTH,
                    life: 25
                });
            }

            if (game.health <= 0) {
                ninja.isDead = true;
                ninja.deathAnim = 120; // 2 second death animation
            }
        }

        function addScore(points, x, y) {
            const actualPoints = points * game.combo;
            game.score += actualPoints;

            // Increase combo
            game.combo = Math.min(4, game.combo + 0.5);
            if (game.combo > Math.floor(game.combo)) {
                game.combo = Math.floor(game.combo);
            } else {
                game.combo = Math.min(4, game.combo + 1);
            }
            game.combo = Math.min(4, Math.floor(game.combo * 2) / 2 + 0.5);
            game.combo = Math.min(4, game.combo);

            // Simpler combo logic
            game.combo = Math.min(4, Math.ceil(game.combo));

            scorePopups.push({
                x: x,
                y: y,
                text: '+' + actualPoints,
                life: 40,
                vy: -1
            });
        }

        // ==================== PARTICLES & EFFECTS ====================
        function updateParticles(dt) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx * dt;
                p.y += p.vy * dt;
                p.vy += 0.3 * dt; // gravity
                p.life -= dt;

                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }

        function updateScorePopups(dt) {
            for (let i = scorePopups.length - 1; i >= 0; i--) {
                const popup = scorePopups[i];
                popup.y += popup.vy * dt;
                popup.life -= dt;

                if (popup.life <= 0) {
                    scorePopups.splice(i, 1);
                }
            }
        }

        // ==================== BACKGROUND ====================
        function updateBackground(dt) {
            // Move ground
            background.groundOffset -= CONFIG.SCROLL_SPEED * dt;
            if (background.groundOffset <= -32) {
                background.groundOffset += 32;
            }

            // Move stars (very slow)
            for (const star of background.stars) {
                star.x -= CONFIG.SCROLL_SPEED * 0.05 * dt;
                if (star.x < 0) {
                    star.x = CONFIG.BASE_WIDTH;
                    star.y = Math.random() * 80;
                }
            }

            // Move clouds (slow)
            for (const c of background.clouds) {
                c.x -= CONFIG.SCROLL_SPEED * 0.15 * dt;
                if (c.x + c.width < 0) {
                    c.x = CONFIG.BASE_WIDTH + Math.random() * 100;
                    c.y = 20 + Math.random() * 30;
                    c.width = 40 + Math.random() * 30;
                }
            }

            // Move mountains (slow)
            for (const m of background.mountains) {
                m.x -= CONFIG.SCROLL_SPEED * 0.2 * dt;
                if (m.x + m.width < 0) {
                    m.x = CONFIG.BASE_WIDTH + Math.random() * 100;
                }
            }

            // Move buildings (medium)
            for (const b of background.buildings) {
                b.x -= CONFIG.SCROLL_SPEED * 0.5 * dt;
                if (b.x + b.width < 0) {
                    b.x = CONFIG.BASE_WIDTH + Math.random() * 50;
                    b.height = 50 + Math.random() * 50;
                    b.hasSign = Math.random() > 0.5;
                    b.color = ['#1a237e', '#0d47a1', '#1565c0'][Math.floor(Math.random() * 3)];
                }
            }
        }

        // ==================== RENDERING ====================
        function render() {
            const ctx = game.ctx;

            // Clear
            ctx.fillStyle = CONFIG.COLORS.SKY;
            ctx.fillRect(0, 0, CONFIG.BASE_WIDTH, CONFIG.BASE_HEIGHT);

            // Draw background
            drawBackground();

            // Draw ground
            drawGround();

            // Draw robots
            for (const robot of robots) {
                drawRobot(robot);
            }

            // Draw fruit
            for (const fruit of fruits) {
                drawFruit(fruit);
            }

            // Draw ninja
            drawNinja();

            // Draw particles
            drawParticles();

            // Draw score popups
            drawScorePopups();

            // Draw UI
            drawUI();

            // Draw game over
            if (game.gameOver) {
                drawGameOver();
            }

            // Draw debug overlay
            drawDebugOverlay();
        }

        function drawBackground() {
            const ctx = game.ctx;
            const time = Date.now() / 1000;

            // Stars (static for performance)
            ctx.fillStyle = '#ffffff';
            for (const star of background.stars) {
                ctx.fillRect(star.x, star.y, star.size, star.size);
            }

            // Moon
            ctx.fillStyle = '#f5f5dc';
            ctx.beginPath();
            ctx.arc(320, 40, 20, 0, Math.PI * 2);
            ctx.fill();
            // Moon craters
            ctx.fillStyle = '#e0e0c0';
            ctx.beginPath();
            ctx.arc(315, 35, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(325, 45, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(318, 48, 2, 0, Math.PI * 2);
            ctx.fill();

            // Clouds (simple rectangles for performance)
            ctx.fillStyle = 'rgba(50, 30, 80, 0.5)';
            for (const c of background.clouds) {
                ctx.fillRect(c.x, c.y, c.width, 12);
                ctx.fillRect(c.x + 10, c.y - 5, c.width - 20, 8);
            }

            // Mountains with snow caps
            for (const m of background.mountains) {
                // Mountain body
                ctx.fillStyle = '#1a1a3e';
                ctx.beginPath();
                ctx.moveTo(m.x, CONFIG.GROUND_Y);
                ctx.lineTo(m.x + m.width / 2, CONFIG.GROUND_Y - m.height);
                ctx.lineTo(m.x + m.width, CONFIG.GROUND_Y);
                ctx.fill();

                // Mountain shading
                ctx.fillStyle = '#12122e';
                ctx.beginPath();
                ctx.moveTo(m.x + m.width / 2, CONFIG.GROUND_Y - m.height);
                ctx.lineTo(m.x + m.width * 0.7, CONFIG.GROUND_Y - m.height * 0.3);
                ctx.lineTo(m.x + m.width, CONFIG.GROUND_Y);
                ctx.lineTo(m.x + m.width / 2, CONFIG.GROUND_Y);
                ctx.fill();

                // Snow cap
                ctx.fillStyle = '#e8e8e8';
                ctx.beginPath();
                ctx.moveTo(m.x + m.width * 0.35, CONFIG.GROUND_Y - m.height * 0.7);
                ctx.lineTo(m.x + m.width / 2, CONFIG.GROUND_Y - m.height);
                ctx.lineTo(m.x + m.width * 0.65, CONFIG.GROUND_Y - m.height * 0.7);
                ctx.lineTo(m.x + m.width * 0.55, CONFIG.GROUND_Y - m.height * 0.75);
                ctx.lineTo(m.x + m.width * 0.45, CONFIG.GROUND_Y - m.height * 0.75);
                ctx.fill();
            }

            // Buildings with details
            for (let bi = 0; bi < background.buildings.length; bi++) {
                const b = background.buildings[bi];
                // Building body
                ctx.fillStyle = b.color;
                ctx.fillRect(b.x, CONFIG.GROUND_Y - b.height, b.width, b.height);

                // Building edge highlight
                ctx.fillStyle = '#2a3a9e';
                ctx.fillRect(b.x, CONFIG.GROUND_Y - b.height, 2, b.height);

                // Building edge shadow
                ctx.fillStyle = '#0a0a2e';
                ctx.fillRect(b.x + b.width - 2, CONFIG.GROUND_Y - b.height, 2, b.height);

                // Roof details
                ctx.fillStyle = '#333';
                ctx.fillRect(b.x, CONFIG.GROUND_Y - b.height, b.width, 3);

                // Windows (stable pattern based on relative position within building)
                const windowSize = 4;
                const windowGap = 10;
                let windowIndex = 0;
                for (let wy = CONFIG.GROUND_Y - b.height + 10; wy < CONFIG.GROUND_Y - 10; wy += windowGap) {
                    for (let wx = b.x + 6; wx < b.x + b.width - 6; wx += windowGap) {
                        // Use building index and window index for stable lighting pattern
                        const isLit = ((bi * 17 + windowIndex * 7) % 10) > 4;
                        ctx.fillStyle = isLit ? '#ffd700' : '#1a1a4e';
                        ctx.fillRect(wx, wy, windowSize, windowSize);
                        windowIndex++;
                    }
                }

                // Neon billboard signs above buildings
                if (b.hasSign && b.height > 70) {
                    const signY = CONFIG.GROUND_Y - b.height - 18; // Above the roof
                    const signColor = ['#ff00ff', '#00ffff', '#ff6600'][bi % 3];
                    // Billboard pole
                    ctx.fillStyle = '#444';
                    ctx.fillRect(b.x + b.width / 2 - 2, CONFIG.GROUND_Y - b.height - 12, 4, 12);
                    // Billboard background
                    ctx.fillStyle = '#222';
                    ctx.fillRect(b.x + 4, signY - 2, b.width - 8, 14);
                    // Neon sign glow
                    ctx.fillStyle = signColor;
                    ctx.fillRect(b.x + 6, signY, b.width - 12, 10);
                    // Inner glow
                    ctx.fillStyle = '#ffffff';
                    ctx.globalAlpha = 0.3;
                    ctx.fillRect(b.x + 8, signY + 2, b.width - 16, 6);
                    ctx.globalAlpha = 1;
                }
            }
        }


        function drawGround() {
            const ctx = game.ctx;

            // Ground fill gradient effect
            ctx.fillStyle = '#3d2066';
            ctx.fillRect(0, CONFIG.GROUND_Y, CONFIG.BASE_WIDTH, 15);
            ctx.fillStyle = CONFIG.COLORS.GROUND;
            ctx.fillRect(0, CONFIG.GROUND_Y + 15, CONFIG.BASE_WIDTH, CONFIG.BASE_HEIGHT - CONFIG.GROUND_Y - 15);

            // Ground top edge (lit)
            ctx.fillStyle = '#9966cc';
            ctx.fillRect(0, CONFIG.GROUND_Y, CONFIG.BASE_WIDTH, 2);

            // Ground secondary line
            ctx.fillStyle = CONFIG.COLORS.GROUND_TOP;
            ctx.fillRect(0, CONFIG.GROUND_Y + 2, CONFIG.BASE_WIDTH, 3);

            // Brick/tile pattern (scrolling)
            for (let x = background.groundOffset; x < CONFIG.BASE_WIDTH; x += 32) {
                // Top row bricks
                ctx.fillStyle = '#6a4c93';
                ctx.fillRect(x, CONFIG.GROUND_Y + 8, 14, 6);
                ctx.fillRect(x + 16, CONFIG.GROUND_Y + 8, 14, 6);

                // Brick highlights
                ctx.fillStyle = '#8066aa';
                ctx.fillRect(x, CONFIG.GROUND_Y + 8, 14, 2);
                ctx.fillRect(x + 16, CONFIG.GROUND_Y + 8, 14, 2);

                // Bottom row bricks (offset)
                ctx.fillStyle = '#5a3c83';
                ctx.fillRect(x + 8, CONFIG.GROUND_Y + 18, 14, 6);
                ctx.fillRect(x + 24, CONFIG.GROUND_Y + 18, 14, 6);

                // Brick shadows
                ctx.fillStyle = '#4a2c73';
                ctx.fillRect(x, CONFIG.GROUND_Y + 12, 14, 2);
                ctx.fillRect(x + 16, CONFIG.GROUND_Y + 12, 14, 2);
                ctx.fillRect(x + 8, CONFIG.GROUND_Y + 22, 14, 2);
            }

            // Bottom edge fade
            ctx.fillStyle = '#2d1656';
            ctx.fillRect(0, CONFIG.GROUND_Y + 28, CONFIG.BASE_WIDTH, CONFIG.BASE_HEIGHT - CONFIG.GROUND_Y - 28);
        }

        function drawNinja() {
            const ctx = game.ctx;
            let x = ninja.x;
            let y = ninja.y;

            const flameTimer = Date.now() / 80;

            // === DEATH ANIMATION ===
            if (ninja.isDead) {
                const deathProgress = 1 - (ninja.deathAnim / 120);
                ctx.save();

                // Fall backwards and fade
                ctx.globalAlpha = Math.max(0, 1 - deathProgress * 0.8);
                const fallAngle = deathProgress * Math.PI * 0.4;
                const fallY = deathProgress * 30;

                ctx.translate(x, y - 16);
                ctx.rotate(fallAngle);
                ctx.translate(-x, -(y - 16));

                y += fallY;

                // Draw dying ninja (simplified)
                // Body falls
                ctx.fillStyle = CONFIG.COLORS.NINJA;
                ctx.fillRect(x - 10, y - 28, 20, 28);

                // Face in pain
                ctx.fillStyle = CONFIG.COLORS.NINJA_SKIN;
                ctx.fillRect(x - 6, y - 26, 12, 10);
                // X eyes
                ctx.fillStyle = '#000';
                ctx.fillRect(x - 4, y - 24, 2, 2);
                ctx.fillRect(x - 2, y - 22, 2, 2);
                ctx.fillRect(x + 2, y - 24, 2, 2);
                ctx.fillRect(x + 4, y - 22, 2, 2);
                // Open mouth
                ctx.fillRect(x - 2, y - 18, 4, 3);

                // Hair
                ctx.fillStyle = CONFIG.COLORS.NINJA_HAIR;
                ctx.fillRect(x - 7, y - 32, 14, 6);

                // Bandana flying off
                ctx.fillStyle = CONFIG.COLORS.HEALTH;
                const bandanaX = x - 20 - deathProgress * 40;
                const bandanaY = y - 30 - deathProgress * 20 + Math.sin(deathProgress * 10) * 10;
                ctx.save();
                ctx.translate(bandanaX, bandanaY);
                ctx.rotate(deathProgress * Math.PI * 2);
                ctx.fillRect(-6, -2, 12, 4);
                ctx.fillRect(6, -1, 8, 2);
                ctx.restore();

                ctx.restore();
                return;
            }

            // Skip drawing every other frame when invincible (flashing)
            if (ninja.invincible > 0 && Math.floor(ninja.invincible / 4) % 2 === 0) {
                return;
            }

            ctx.save();

            // === HIT REACTION ===
            let hitShake = 0;
            let hitTilt = 0;
            if (ninja.hitReaction > 0) {
                hitShake = Math.sin(ninja.hitReaction * 2) * 3;
                hitTilt = Math.sin(ninja.hitReaction * 0.5) * 0.2;
                x += hitShake;

                // Tilt the character when hit
                ctx.translate(x, y - 16);
                ctx.rotate(hitTilt);
                ctx.translate(-x, -(y - 16));
            }

            // Determine pose
            let bobY = 0;
            if (!ninja.isJumping && ninja.hitReaction === 0) {
                bobY = Math.sin(ninja.animFrame * Math.PI / 2) * 2;
            }

            // === RED BANDANA ===
            ctx.fillStyle = CONFIG.COLORS.HEALTH;
            ctx.fillRect(x - 8, y - 29 + bobY, 16, 4);  // Main bandana
            // Bandana knot
            ctx.fillRect(x - 10, y - 28 + bobY, 3, 3);
            // Flowing tails (animated)
            const tailWave = Math.sin(flameTimer * 1.5) * 2;
            const tailWave2 = Math.sin(flameTimer * 1.5 + 1) * 2;
            ctx.fillRect(x - 14 - tailWave, y - 28 + bobY, 5, 2);
            ctx.fillRect(x - 18 - tailWave2, y - 27 + bobY, 5, 2);
            ctx.fillRect(x - 12 - tailWave, y - 30 + bobY, 4, 2);
            ctx.fillRect(x - 16 - tailWave2, y - 29 + bobY, 4, 2);
            // Bandana shadow
            ctx.fillStyle = '#c0392b';
            ctx.fillRect(x - 8, y - 26 + bobY, 16, 1);

            // === BLOND HAIR ===
            ctx.fillStyle = CONFIG.COLORS.NINJA_HAIR;
            ctx.fillRect(x - 7, y - 33 + bobY, 14, 5);  // Top of hair
            ctx.fillRect(x - 8, y - 29 + bobY, 4, 3);   // Left side hair
            ctx.fillRect(x + 4, y - 29 + bobY, 4, 3);   // Right side hair
            // Hair spikes
            ctx.fillRect(x - 5, y - 36 + bobY, 3, 4);
            ctx.fillRect(x + 1, y - 37 + bobY, 3, 5);
            ctx.fillRect(x + 5, y - 35 + bobY, 3, 3);
            // Hair highlight
            ctx.fillStyle = '#fff59d';
            ctx.fillRect(x - 3, y - 35 + bobY, 3, 2);
            ctx.fillRect(x + 2, y - 36 + bobY, 2, 2);
            // Hair shadow
            ctx.fillStyle = CONFIG.COLORS.NINJA_HAIR_DARK;
            ctx.fillRect(x - 6, y - 30 + bobY, 3, 2);
            ctx.fillRect(x + 4, y - 30 + bobY, 3, 2);

            // === FACE ===
            ctx.fillStyle = CONFIG.COLORS.NINJA_SKIN;
            ctx.fillRect(x - 6, y - 26 + bobY, 12, 10);

            // Eyes - change expression when hit
            if (ninja.hitReaction > 0) {
                // Hurt expression - squinting
                ctx.fillStyle = '#000';
                ctx.fillRect(x - 4, y - 23 + bobY, 4, 1);
                ctx.fillRect(x + 1, y - 23 + bobY, 4, 1);
                // Gritted teeth
                ctx.fillStyle = '#fff';
                ctx.fillRect(x - 2, y - 18 + bobY, 5, 2);
                ctx.fillStyle = '#000';
                ctx.fillRect(x - 1, y - 17 + bobY, 1, 1);
                ctx.fillRect(x + 1, y - 17 + bobY, 1, 1);
            } else {
                // Normal eyes
                ctx.fillStyle = '#fff';
                ctx.fillRect(x - 4, y - 24 + bobY, 4, 3);
                ctx.fillRect(x + 1, y - 24 + bobY, 4, 3);
                ctx.fillStyle = '#2196f3';
                ctx.fillRect(x - 2, y - 24 + bobY, 2, 3);
                ctx.fillRect(x + 3, y - 24 + bobY, 2, 3);
                // Eye shine
                ctx.fillStyle = '#fff';
                ctx.fillRect(x - 3, y - 24 + bobY, 1, 1);
                ctx.fillRect(x + 2, y - 24 + bobY, 1, 1);
                // Determined eyebrows
                ctx.fillStyle = CONFIG.COLORS.NINJA_HAIR_DARK;
                ctx.fillRect(x - 4, y - 25 + bobY, 3, 1);
                ctx.fillRect(x + 2, y - 25 + bobY, 3, 1);
                // Mouth
                ctx.fillStyle = '#e57373';
                ctx.fillRect(x - 1, y - 18 + bobY, 3, 1);
            }

            // === BLACK NINJA MASK (around neck/lower face) ===
            ctx.fillStyle = CONFIG.COLORS.NINJA;
            ctx.fillRect(x - 7, y - 17 + bobY, 14, 3);

            // === BLACK NINJA BODY ===
            ctx.fillStyle = CONFIG.COLORS.NINJA;
            ctx.fillRect(x - 10, y - 14 + bobY, 20, 14);
            // Body shading
            ctx.fillStyle = CONFIG.COLORS.NINJA_ACCENT;
            ctx.fillRect(x - 8, y - 12 + bobY, 4, 10);
            ctx.fillRect(x + 4, y - 12 + bobY, 4, 10);
            // Chest detail / fold lines
            ctx.fillStyle = '#444';
            ctx.fillRect(x - 1, y - 12 + bobY, 2, 8);

            // === RED BELT ===
            ctx.fillStyle = CONFIG.COLORS.HEALTH;
            ctx.fillRect(x - 10, y - 4 + bobY, 20, 3);
            ctx.fillStyle = '#ffeb3b';
            ctx.fillRect(x - 2, y - 4 + bobY, 4, 3);

            // === LEGS ===
            ctx.fillStyle = CONFIG.COLORS.NINJA;
            if (ninja.isJumping) {
                ctx.fillRect(x - 9, y - 2, 8, 6);
                ctx.fillRect(x + 1, y - 4, 8, 6);
                ctx.fillStyle = '#4a4a4a';
                ctx.fillRect(x - 10, y + 2, 6, 3);
                ctx.fillRect(x + 4, y, 6, 3);
            } else {
                const legOffset = Math.sin(ninja.animFrame * Math.PI / 2) * 5;
                ctx.fillRect(x - 9, y - 2, 7, 6);
                ctx.fillRect(x + 2, y - 2, 7, 6);
                ctx.fillStyle = '#4a4a4a';
                ctx.fillRect(x - 11 + legOffset, y + 2, 7, 3);
                ctx.fillRect(x + 4 - legOffset, y + 2, 7, 3);
            }

            // === ARMS & SWORD ===
            const slashProgress = ninja.isSlashing ? (1 - ninja.slashTimer / CONFIG.SLASH_DURATION) : 0;

            // Sword swing angle: held backward, swings forward toward robots
            // Robots come from the right, so slash goes from back (left/up) to front (right)
            let swordAngle;
            if (ninja.isSlashing) {
                // Smooth swing arc using easeOutQuad
                const eased = 1 - (1 - slashProgress) * (1 - slashProgress);
                swordAngle = -2.2 + eased * 2.6; // -2.2 rad to +0.4 rad (~-125Â° to +25Â°)
            } else {
                // Ready position - sword held back, ready to swing forward
                swordAngle = -2.0 + Math.sin(flameTimer * 0.5) * 0.08; // Pointing backward with subtle sway
            }

            const swordLength = 32;
            const swordPivotX = x + 12;
            const swordPivotY = y - 10 + bobY;

            // Calculate sword tip position
            const swordTipX = swordPivotX + Math.cos(swordAngle) * swordLength;
            const swordTipY = swordPivotY + Math.sin(swordAngle) * swordLength;

            // Left arm (always visible)
            ctx.fillStyle = CONFIG.COLORS.NINJA;
            ctx.fillRect(x - 14, y - 12 + bobY, 5, 8);
            ctx.fillStyle = CONFIG.COLORS.NINJA_SKIN;
            ctx.fillRect(x - 14, y - 6 + bobY, 4, 4);

            // Right arm holding sword
            ctx.save();
            ctx.translate(swordPivotX, swordPivotY);
            ctx.rotate(swordAngle);

            // Arm
            ctx.fillStyle = CONFIG.COLORS.NINJA;
            ctx.fillRect(-4, -3, 10, 6);
            // Hand gripping
            ctx.fillStyle = CONFIG.COLORS.NINJA_SKIN;
            ctx.fillRect(4, -2, 5, 5);

            // === FLAMING SWORD ===
            // Handle
            ctx.fillStyle = '#5d4037';
            ctx.fillRect(8, -2, 6, 5);
            // Handle wrap
            ctx.fillStyle = '#8b0000';
            ctx.fillRect(9, -1, 2, 3);
            ctx.fillRect(12, -1, 2, 3);
            // Guard (cross guard)
            ctx.fillStyle = '#ffd700';
            ctx.fillRect(6, -4, 3, 9);
            ctx.fillStyle = '#ffab00';
            ctx.fillRect(6, -1, 3, 3);

            // Blade
            ctx.fillStyle = '#b0bec5';
            ctx.fillRect(14, -2, swordLength - 14, 5);
            // Blade edge highlight
            ctx.fillStyle = '#eceff1';
            ctx.fillRect(14, -2, swordLength - 14, 2);
            // Blade center fuller
            ctx.fillStyle = '#78909c';
            ctx.fillRect(16, 0, swordLength - 18, 2);
            // Blade tip
            ctx.fillStyle = '#eceff1';
            ctx.beginPath();
            ctx.moveTo(swordLength - 2, -2);
            ctx.lineTo(swordLength + 4, 1);
            ctx.lineTo(swordLength - 2, 4);
            ctx.fill();

            // === FLAMES ALONG THE BLADE (simplified) ===
            const flicker = ((Date.now() / 50) % 4) - 2; // Simple flicker without sin
            for (let i = 0; i < 4; i++) {
                const flameX = 18 + i * 5;
                ctx.fillStyle = CONFIG.COLORS.FLAME_TIP;
                ctx.fillRect(flameX, -4 + (i % 2) * flicker, 3, 3);
                ctx.fillStyle = CONFIG.COLORS.FLAME_OUTER;
                ctx.fillRect(flameX, 3 - (i % 2) * flicker, 3, 3);
            }

            // Tip flame
            const tipFlicker = ((Date.now() / 40) % 4) - 2;
            ctx.fillStyle = CONFIG.COLORS.FLAME_TIP;
            ctx.fillRect(swordLength, -4 - tipFlicker, 5, 5);
            ctx.fillRect(swordLength + 2, 2 + tipFlicker * 0.5, 4, 4);
            ctx.fillStyle = CONFIG.COLORS.FLAME_OUTER;
            ctx.fillRect(swordLength + 2, -2 - tipFlicker * 0.5, 4, 4);
            ctx.fillStyle = CONFIG.COLORS.FLAME_MID;
            ctx.fillRect(swordLength + 1, 0, 3, 2);

            ctx.restore();

            // === SLASH TRAIL (simplified for performance) ===
            if (ninja.isSlashing && slashProgress > 0.2) {
                ctx.save();

                // Fewer trail segments for mobile performance
                for (let i = 0; i < 5; i++) {
                    const segmentProgress = slashProgress - (i * 0.12);
                    if (segmentProgress < 0) continue;

                    const segmentEased = 1 - (1 - segmentProgress) * (1 - segmentProgress);
                    const trailAngle = -2.2 + segmentEased * 2.6;

                    const trailX = swordPivotX + Math.cos(trailAngle) * (swordLength + 4);
                    const trailY = swordPivotY + Math.sin(trailAngle) * (swordLength + 4);

                    const size = 6 + (5 - i) * 2;

                    ctx.globalAlpha = (1 - i / 5) * 0.6;
                    ctx.fillStyle = CONFIG.COLORS.FLAME_OUTER;
                    ctx.fillRect(trailX - size/2, trailY - size/2, size, size);
                }

                ctx.globalAlpha = 1;
                ctx.restore();
            }

            ctx.restore();
        }

        function drawRobot(robot) {
            const ctx = game.ctx;
            const x = robot.x;
            const y = robot.y;
            const isTall = robot.isTall;

            ctx.save();

            const bobY = Math.sin(robot.animFrame * Math.PI / 2) * 2;

            if (isTall) {
                // === TALL MECH ROBOT ===
                // Legs
                ctx.fillStyle = '#444';
                const legOffset = Math.sin(robot.animFrame * Math.PI / 2) * 3;
                ctx.fillRect(x - 10 - legOffset, y - 8, 8, 10);
                ctx.fillRect(x + 2 + legOffset, y - 8, 8, 10);
                // Leg joints
                ctx.fillStyle = '#666';
                ctx.fillRect(x - 8 - legOffset, y - 6, 4, 4);
                ctx.fillRect(x + 4 + legOffset, y - 6, 4, 4);
                // Feet
                ctx.fillStyle = CONFIG.COLORS.ROBOT_ACCENT;
                ctx.fillRect(x - 12 - legOffset, y, 10, 3);
                ctx.fillRect(x + 2 + legOffset, y, 10, 3);

                // Body
                ctx.fillStyle = '#555';
                ctx.fillRect(x - 14, y - 32 + bobY, 28, 26);
                // Body armor plates
                ctx.fillStyle = CONFIG.COLORS.ROBOT_BODY;
                ctx.fillRect(x - 12, y - 30 + bobY, 24, 10);
                ctx.fillRect(x - 10, y - 18 + bobY, 20, 10);
                // Body details
                ctx.fillStyle = '#333';
                ctx.fillRect(x - 8, y - 28 + bobY, 16, 2);
                ctx.fillRect(x - 6, y - 16 + bobY, 12, 2);
                // Chest core
                ctx.fillStyle = CONFIG.COLORS.ROBOT_ACCENT;
                ctx.fillRect(x - 4, y - 24 + bobY, 8, 6);
                ctx.fillStyle = '#ffff00';
                ctx.fillRect(x - 2, y - 22 + bobY, 4, 2);

                // Head
                ctx.fillStyle = '#666';
                ctx.fillRect(x - 10, y - 40 + bobY, 20, 10);
                ctx.fillStyle = CONFIG.COLORS.ROBOT_BODY;
                ctx.fillRect(x - 8, y - 38 + bobY, 16, 6);
                // Visor
                ctx.fillStyle = '#222';
                ctx.fillRect(x - 7, y - 37 + bobY, 14, 4);
                // Eyes
                ctx.fillStyle = CONFIG.COLORS.ROBOT_EYES;
                ctx.fillRect(x - 5, y - 36 + bobY, 4, 2);
                ctx.fillRect(x + 1, y - 36 + bobY, 4, 2);

                // Antenna
                ctx.fillStyle = '#888';
                ctx.fillRect(x - 1, y - 46 + bobY, 2, 6);
                ctx.fillStyle = CONFIG.COLORS.ROBOT_ACCENT;
                ctx.fillRect(x - 2, y - 48 + bobY, 4, 3);
                // Antenna light
                ctx.fillStyle = ((Date.now() / 300) % 2) > 1 ? '#ff0000' : '#660000';
                ctx.fillRect(x - 1, y - 47 + bobY, 2, 2);

                // Arms
                ctx.fillStyle = '#555';
                ctx.fillRect(x - 18, y - 28 + bobY, 6, 14);
                ctx.fillRect(x + 12, y - 28 + bobY, 6, 14);
                // Claws
                ctx.fillStyle = CONFIG.COLORS.ROBOT_ACCENT;
                ctx.fillRect(x - 19, y - 16 + bobY, 3, 6);
                ctx.fillRect(x - 15, y - 16 + bobY, 3, 6);
                ctx.fillRect(x + 12, y - 16 + bobY, 3, 6);
                ctx.fillRect(x + 16, y - 16 + bobY, 3, 6);

            } else {
                // === SMALL SCOUT ROBOT ===
                // Legs
                ctx.fillStyle = '#444';
                const legOffset = Math.sin(robot.animFrame * Math.PI / 2) * 3;
                ctx.fillRect(x - 7 - legOffset, y - 5, 5, 6);
                ctx.fillRect(x + 2 + legOffset, y - 5, 5, 6);
                // Feet
                ctx.fillStyle = CONFIG.COLORS.ROBOT_ACCENT;
                ctx.fillRect(x - 9 - legOffset, y, 7, 2);
                ctx.fillRect(x + 2 + legOffset, y, 7, 2);

                // Body
                ctx.fillStyle = '#555';
                ctx.fillRect(x - 10, y - 22 + bobY, 20, 18);
                ctx.fillStyle = CONFIG.COLORS.ROBOT_BODY;
                ctx.fillRect(x - 8, y - 20 + bobY, 16, 14);
                // Chest panel
                ctx.fillStyle = '#333';
                ctx.fillRect(x - 5, y - 18 + bobY, 10, 8);
                // Power core
                ctx.fillStyle = CONFIG.COLORS.ROBOT_ACCENT;
                ctx.fillRect(x - 3, y - 16 + bobY, 6, 4);
                ctx.fillStyle = '#ffff00';
                ctx.fillRect(x - 1, y - 14 + bobY, 2, 2);

                // Head
                ctx.fillStyle = '#666';
                ctx.fillRect(x - 8, y - 28 + bobY, 16, 8);
                ctx.fillStyle = CONFIG.COLORS.ROBOT_BODY;
                ctx.fillRect(x - 6, y - 26 + bobY, 12, 4);
                // Eyes
                ctx.fillStyle = '#222';
                ctx.fillRect(x - 5, y - 26 + bobY, 10, 3);
                ctx.fillStyle = CONFIG.COLORS.ROBOT_EYES;
                ctx.fillRect(x - 4, y - 25 + bobY, 3, 2);
                ctx.fillRect(x + 1, y - 25 + bobY, 3, 2);

                // Antenna
                ctx.fillStyle = '#888';
                ctx.fillRect(x - 1, y - 32 + bobY, 2, 4);
                ctx.fillStyle = CONFIG.COLORS.ROBOT_ACCENT;
                ctx.fillRect(x - 2, y - 34 + bobY, 4, 3);

                // Arms
                ctx.fillStyle = '#555';
                ctx.fillRect(x - 13, y - 18 + bobY, 4, 10);
                ctx.fillRect(x + 9, y - 18 + bobY, 4, 10);
                ctx.fillStyle = CONFIG.COLORS.ROBOT_ACCENT;
                ctx.fillRect(x - 13, y - 10 + bobY, 4, 3);
                ctx.fillRect(x + 9, y - 10 + bobY, 4, 3);
            }

            ctx.restore();
        }

        function drawFruit(fruit) {
            const ctx = game.ctx;
            const x = fruit.x;
            const bobY = Math.sin(fruit.bobTimer + fruit.bobOffset) * 5;
            const y = fruit.y + bobY;

            ctx.save();

            const type = fruit.type.name;

            if (type === 'pineapple') {
                // Pineapple body
                ctx.fillStyle = fruit.type.bodyColor;
                ctx.fillRect(x - 7, y - 6, 14, 16);
                // Pattern
                ctx.fillStyle = '#c9a227';
                for (let py = -4; py < 8; py += 4) {
                    for (let px = -5; px < 6; px += 4) {
                        ctx.fillRect(x + px, y + py, 2, 2);
                    }
                }
                // Leaves
                ctx.fillStyle = fruit.type.topColor;
                ctx.fillRect(x - 3, y - 12, 2, 6);
                ctx.fillRect(x + 1, y - 14, 2, 8);
                ctx.fillRect(x - 5, y - 10, 2, 4);
                ctx.fillRect(x + 3, y - 10, 2, 4);
            } else if (type === 'banana') {
                // Banana curve
                ctx.fillStyle = fruit.type.bodyColor;
                ctx.fillRect(x - 8, y - 2, 4, 8);
                ctx.fillRect(x - 5, y - 5, 4, 10);
                ctx.fillRect(x - 2, y - 6, 4, 10);
                ctx.fillRect(x + 2, y - 5, 4, 8);
                ctx.fillRect(x + 5, y - 2, 4, 5);
                // Tips
                ctx.fillStyle = fruit.type.topColor;
                ctx.fillRect(x - 8, y + 4, 3, 3);
                ctx.fillRect(x + 6, y - 2, 3, 2);
            } else if (type === 'cherry') {
                // Two cherries
                ctx.fillStyle = fruit.type.bodyColor;
                ctx.beginPath();
                ctx.arc(x - 5, y + 2, 6, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(x + 5, y + 4, 6, 0, Math.PI * 2);
                ctx.fill();
                // Stems
                ctx.fillStyle = fruit.type.topColor;
                ctx.fillRect(x - 5, y - 8, 2, 10);
                ctx.fillRect(x + 5, y - 6, 2, 10);
                ctx.fillRect(x - 4, y - 10, 10, 2);
                // Shine
                ctx.fillStyle = '#fff';
                ctx.fillRect(x - 7, y, 2, 2);
                ctx.fillRect(x + 3, y + 2, 2, 2);
            } else if (type === 'apple') {
                // Apple body
                ctx.fillStyle = fruit.type.bodyColor;
                ctx.fillRect(x - 7, y - 4, 14, 12);
                ctx.fillRect(x - 5, y - 6, 10, 2);
                ctx.fillRect(x - 5, y + 8, 10, 2);
                // Stem
                ctx.fillStyle = '#8b4513';
                ctx.fillRect(x - 1, y - 10, 2, 5);
                // Leaf
                ctx.fillStyle = fruit.type.topColor;
                ctx.fillRect(x + 1, y - 10, 5, 3);
                // Shine
                ctx.fillStyle = '#fff';
                ctx.fillRect(x - 4, y - 2, 3, 3);
            } else if (type === 'strawberry') {
                // Strawberry body
                ctx.fillStyle = fruit.type.bodyColor;
                ctx.fillRect(x - 6, y - 6, 12, 8);
                ctx.fillRect(x - 4, y + 2, 8, 4);
                ctx.fillRect(x - 2, y + 6, 4, 2);
                // Seeds
                ctx.fillStyle = '#f1c40f';
                ctx.fillRect(x - 3, y - 3, 2, 2);
                ctx.fillRect(x + 2, y - 1, 2, 2);
                ctx.fillRect(x - 1, y + 2, 2, 2);
                // Leaves
                ctx.fillStyle = fruit.type.topColor;
                ctx.fillRect(x - 5, y - 9, 10, 4);
                ctx.fillRect(x - 7, y - 7, 3, 2);
                ctx.fillRect(x + 4, y - 7, 3, 2);
            }

            ctx.restore();
        }

        function drawParticles() {
            const ctx = game.ctx;

            for (const p of particles) {
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life / 30;
                ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
            }
            ctx.globalAlpha = 1;
        }

        function drawScorePopups() {
            const ctx = game.ctx;

            ctx.font = '8px monospace';
            ctx.textAlign = 'center';

            for (const popup of scorePopups) {
                ctx.fillStyle = CONFIG.COLORS.SLASH;
                ctx.globalAlpha = popup.life / 40;
                ctx.fillText(popup.text, popup.x, popup.y);
            }
            ctx.globalAlpha = 1;
        }

        function drawUI() {
            const ctx = game.ctx;

            // Score
            ctx.fillStyle = CONFIG.COLORS.UI_TEXT;
            ctx.font = 'bold 12px monospace';
            ctx.textAlign = 'left';
            ctx.fillText('SCORE: ' + String(game.score).padStart(6, '0'), 10, 20);

            // Combo
            if (game.combo > 1) {
                ctx.fillStyle = CONFIG.COLORS.SLASH;
                ctx.fillText(game.combo + 'x COMBO', 10, 34);
            }

            // Health (ninja stars)
            ctx.textAlign = 'right';
            ctx.fillStyle = CONFIG.COLORS.HEALTH;
            for (let i = 0; i < game.health; i++) {
                drawStar(CONFIG.BASE_WIDTH - 20 - i * 18, 14, 6);
            }
        }

        function drawStar(cx, cy, r) {
            const ctx = game.ctx;
            ctx.beginPath();
            for (let i = 0; i < 5; i++) {
                const angle = (i * 4 * Math.PI / 5) - Math.PI / 2;
                const x = cx + Math.cos(angle) * r;
                const y = cy + Math.sin(angle) * r;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fill();
        }

        function drawDebugOverlay() {
            if (!DEBUG.showFps) return;

            const ctx = game.ctx;

            // Background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(5, CONFIG.BASE_HEIGHT - 35, 70, 30);

            // FPS color: green if 55+, yellow if 40-55, red if <40
            const fpsColor = DEBUG.fps >= 55 ? '#44ff44' : (DEBUG.fps >= 40 ? '#ffff44' : '#ff4444');

            ctx.font = 'bold 10px monospace';
            ctx.textAlign = 'left';
            ctx.fillStyle = fpsColor;
            ctx.fillText(`FPS: ${DEBUG.fps}`, 10, CONFIG.BASE_HEIGHT - 20);

            ctx.font = '8px monospace';
            ctx.fillStyle = '#aaaaaa';
            ctx.fillText(`${DEBUG.frameTime.toFixed(1)}ms/frame`, 10, CONFIG.BASE_HEIGHT - 9);
        }

        function drawGameOver() {
            const ctx = game.ctx;

            // Darken background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, CONFIG.BASE_WIDTH, CONFIG.BASE_HEIGHT);

            ctx.textAlign = 'center';

            if (game.enteringName) {
                // Compact layout to fit keyboard in viewport
                // GAME OVER text
                ctx.fillStyle = CONFIG.COLORS.HEALTH;
                ctx.font = 'bold 18px monospace';
                ctx.fillText('GAME OVER', CONFIG.BASE_WIDTH / 2, 22);

                // Final score
                ctx.fillStyle = CONFIG.COLORS.UI_TEXT;
                ctx.font = 'bold 12px monospace';
                ctx.fillText('SCORE: ' + game.score, CONFIG.BASE_WIDTH / 2, 40);

                // New high score!
                ctx.fillStyle = CONFIG.COLORS.SLASH;
                ctx.font = 'bold 10px monospace';
                ctx.fillText('NEW HIGH SCORE!', CONFIG.BASE_WIDTH / 2, 56);

                // Name entry boxes
                ctx.font = 'bold 14px monospace';
                const displayName = game.playerName.padEnd(3, '_');
                const startX = CONFIG.BASE_WIDTH / 2 - 30;
                for (let i = 0; i < 3; i++) {
                    const letterX = startX + i * 20;

                    // Box background
                    ctx.fillStyle = i < game.playerName.length ? '#5c6bc0' : '#333';
                    ctx.fillRect(letterX, 65, 18, 20);

                    // Letter
                    ctx.fillStyle = CONFIG.COLORS.UI_TEXT;
                    ctx.fillText(displayName[i], letterX + 9, 80);
                }

                // Draw on-screen keyboard
                drawTouchKeyboard();

            } else {
                // Standard game over (no high score)
                ctx.fillStyle = CONFIG.COLORS.HEALTH;
                ctx.font = 'bold 24px monospace';
                ctx.fillText('GAME OVER', CONFIG.BASE_WIDTH / 2, CONFIG.BASE_HEIGHT / 2 - 20);

                // Final score
                ctx.fillStyle = CONFIG.COLORS.UI_TEXT;
                ctx.font = 'bold 14px monospace';
                ctx.fillText('FINAL SCORE: ' + game.score, CONFIG.BASE_WIDTH / 2, CONFIG.BASE_HEIGHT / 2 + 10);

                // Restart prompt
                ctx.font = '10px monospace';
                ctx.fillText('Press SPACE or tap to play again', CONFIG.BASE_WIDTH / 2, CONFIG.BASE_HEIGHT / 2 + 35);
            }
        }

        // ==================== TOUCH KEYBOARD ====================
        function drawTouchKeyboard() {
            const ctx = game.ctx;
            const btnSize = 20;
            const gap = 2;
            const cols = 9;
            const startX = (CONFIG.BASE_WIDTH - (cols * (btnSize + gap))) / 2;
            const startY = 92; // Fixed position below name entry

            // Store keyboard position for hit detection
            touchKeyboard.startX = startX;
            touchKeyboard.startY = startY;
            touchKeyboard.btnSize = btnSize;
            touchKeyboard.gap = gap;
            touchKeyboard.cols = cols;

            // Draw letter buttons (3 rows)
            for (let i = 0; i < 26; i++) {
                const row = Math.floor(i / cols);
                const col = i % cols;
                const x = startX + col * (btnSize + gap);
                const y = startY + row * (btnSize + gap);

                // Button background
                ctx.fillStyle = '#444';
                ctx.fillRect(x, y, btnSize, btnSize);
                ctx.fillStyle = '#666';
                ctx.fillRect(x, y, btnSize, 2);

                // Letter
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 10px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(touchKeyboard.letters[i], x + btnSize/2, y + btnSize/2 + 4);
            }

            // Bottom row: DEL and OK buttons
            const bottomY = startY + 3 * (btnSize + gap);

            // Backspace button
            const bsX = startX;
            ctx.fillStyle = '#833';
            ctx.fillRect(bsX, bottomY, btnSize * 2 + gap, btnSize);
            ctx.fillStyle = '#a55';
            ctx.fillRect(bsX, bottomY, btnSize * 2 + gap, 2);
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 10px monospace';
            ctx.fillText('DEL', bsX + (btnSize * 2 + gap) / 2, bottomY + btnSize/2 + 4);

            // OK button (only if 3 letters entered)
            const okX = startX + 6 * (btnSize + gap);
            const okEnabled = game.playerName.length === 3;
            ctx.fillStyle = okEnabled ? '#383' : '#333';
            ctx.fillRect(okX, bottomY, btnSize * 3, btnSize);
            if (okEnabled) {
                ctx.fillStyle = '#5a5';
                ctx.fillRect(okX, bottomY, btnSize * 3, 2);
            }
            ctx.fillStyle = okEnabled ? '#fff' : '#666';
            ctx.fillText('OK', okX + (btnSize * 3) / 2, bottomY + btnSize/2 + 4);

            // Hint text
            ctx.fillStyle = '#888';
            ctx.font = '8px monospace';
            ctx.fillText('Tap or type letters', CONFIG.BASE_WIDTH / 2, bottomY + btnSize + 12);

            ctx.textAlign = 'left';
        }

        function handleKeyboardTouch(canvasX, canvasY) {
            if (!game.enteringName) return false;

            const kb = touchKeyboard;
            const btnSize = kb.btnSize;
            const gap = kb.gap;
            const cols = kb.cols;
            const startX = kb.startX;
            const startY = kb.startY;

            // Check letter buttons (3 rows of 9)
            for (let i = 0; i < 26; i++) {
                const row = Math.floor(i / cols);
                const col = i % cols;
                const x = startX + col * (btnSize + gap);
                const y = startY + row * (btnSize + gap);

                if (canvasX >= x && canvasX < x + btnSize &&
                    canvasY >= y && canvasY < y + btnSize) {
                    if (game.playerName.length < 3) {
                        game.playerName += kb.letters[i];
                    }
                    return true;
                }
            }

            const bottomY = startY + 3 * (btnSize + gap);

            // Check backspace (DEL)
            const bsX = startX;
            if (canvasX >= bsX && canvasX < bsX + btnSize * 2 + gap &&
                canvasY >= bottomY && canvasY < bottomY + btnSize) {
                if (game.playerName.length > 0) {
                    game.playerName = game.playerName.slice(0, -1);
                }
                return true;
            }

            // Check OK button
            const okX = startX + 6 * (btnSize + gap);
            if (canvasX >= okX && canvasX < okX + btnSize * 3 &&
                canvasY >= bottomY && canvasY < bottomY + btnSize) {
                if (game.playerName.length === 3) {
                    addHighScore(game.playerName, game.score, game.newHighScoreRank);
                    game.enteringName = false;
                }
                return true;
            }

            return false;
        }

        // ==================== START GAME ====================
        window.addEventListener('load', init);
    </script>
</body>
</html>
